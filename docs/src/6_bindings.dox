/**
 * \page bindings Bindings

\tableofcontents

\section python Python

The generation of python bindings has the objective to simplify the usage of the library, allowing 
users without low level programming experience to exploit the library in their applications. Python is a natural 
choice because of its wide usage and its simplicity. Using DistDir library in a python script allows to fully hide the 
complexity of the language and the algorithm to the end users.

A python module `pydistdir` can be generated by adding \c -DENABLE_PYTHON=ON option to the configuration command 
described in the \ref installation page. Once the python module is installed, the folder where the pythonn module is 
installed needs to be added to the `PYTHONPATH` environment variable.
The generation of the python module requires `cython` and `mpi4py` which can be 
easily installed using `pip`.

This section describes the usage of the library in a python script. The basic principles of the library are still 
the same, but the interface is slightly different because Python is an object oriented language.

First of all, the module must be loaded

\code
import pydistdir
\endcode

Then the library needs to be initialized by calling the constructor of the `distdir` class

\code
dd = pydistdir.distdir()
\endcode

The finalization step is handled by python after that all the destructors of the generated objects are called by 
the garbage collector, so the user does not need to worry to destroy objects or finalize the library.

A new group can be created using a method of the main `distdir` class

\code
dd.group(new_comm, work_comm, id)
\endcode

where the `work_comm` is the communicator containing all the processes running the application, the `id` is an integer 
which defines in which group each process belongs and `new_comm` is the new communicator.

The `distdir` class also contains methods to setup the library

\code
dd.verbose(pydistdir.pydistdir_verbose.verbose_true)
dd.exchanger(pydistdir.pydistdir_exchanger.IsendIrecv1)
\endcode

The \c verbose method has an object of `pydistdir_verbose` class which is an integer enumerator and the \c exchanger 
method has an object of `pydistdir_exchanger` class which is also an integer enumerator. They are defined as follows:

\code
class pydistdir_verbose(IntEnum):
	verbose_true  = 0
	verbose_false = 1
\endcode

\code
class pydistdir_exchanger(IntEnum):
	IsendIrecv1       = 0
	IsendIrecv2       = 1
	IsendRecv1        = 2
	IsendRecv2        = 3
	IsendIrecv1NoWait = 4
	IsendIrecv2NoWait = 5
	IsendRecv1NoWait  = 6
	IsendRecv2NoWait  = 7
\endcode

A `idxlist` class is defined in the bindings and it allows to create an index list object which can be created
easily by passying a `numpy` array or a tuple:

\code
src_idxlist = pydistdir.idxlist([0, 1, 4, 5, 8, 9, 12, 13])
\endcode

An empty index list object can be created not passing any array to the constructor of the `idxlist` class:

\code
dst_idxlist = pydistdir.idxlist()
\endcode

A `map` object can be created by passing the source and destination `idxlist` objects and the MPI communicator:

\code
map = pydistdir.map(src_idxlist=src_idxlist, dst_idxlist=dst_idxlist, comm=MPI.COMM_WORLD)
\endcode

In addition the `stride` argument can be passed explicitly (the default stride is -1 which means that striding is not 
used):

\code
map = pydistdir.map(src_idxlist=src_idxlist, dst_idxlist=dst_idxlist, comm=MPI.COMM_WORLD, stride=8)
\endcode

In case the `map` object is generated expanding a 2D map, the following constructor can be called:

\code
map = pydistdir.map(map2d=map2d, nlevels=10)
\endcode

where the `map2d` objects was generated by a previous call to \c pydistdir.map.

An `exchanger` object can be generated passing the `map` object, the hardware type and 
the MPI datatype

\code
exchanger = pydistdir.exchanger(map, hw, type)
\endcode

where the `hw` argument is a class defined as an integer enumerator:

\code
class pydistdir_hardware(IntEnum):
	CPU        = 0
	GPU_NVIDIA = 1
	GPU_AMD    = 2
\endcode

and type is an MPI datatype. The following MPI datatypes are supported: `MPI.DOUBLE`, `MPI.FLOAT` and `MPI.INT`.

The default hardware is the `CPU` and the default type is `MPI.DOUBLE`, so the exchanger can also be created providing 
only the `map` object:

\code
exchanger = pydistdir.exchanger(map)
\endcode

The data to be exchanger can be allocated as a `numpy` array:

\code
data = np.array([0, 1, 2, 3, 4, 5, 6, 7], dtype = np.double)
\endcode

Finally, the `exchanger` class has a `go` method which performs the actual exchange:

\code
exchanger.go(data, data)
\endcode

If a transformation is provided on the data layout, the following method can be used:

\code
exchanger.go(data, data, transform_src, transform_dst)
\endcode

where `transform_src` and `transform_dst` are integer `numpy` arrays.

The destructors of the `idxlist`, `map` and `exchanger` classes free the memory internally allocated by the library.

Overall, the Python bindings provide the following classes:

 - `distdir`: initialize the library, create new group and handle the library settings
 - `idxlist`: create and destroy and index list
 - `map`: create and destroy a map
 - `exchanger`: create and destroy an exchanger and performs the actual exchange

If compared with the C API described in the \ref start page, the python interface is significantly easier even if with 
minor limitations which will be tackled in future developments.

All the C examples provided in the `examples` folder are replicated in python in the `bindings/python/examples` folder.





\section cpp C++

A tiny wrapper around the library is generated to provide C++ bindings. This is not strictly necessary because a C library
can be called directly from C++, but since C++ is an object oriented language, a class-based interface
is provided. The header file `distdir.hpp` should be included. This is installed in the `include`
folder by adding \c -DENABLE_CXX=ON. The classed belonging to the C++ interface are all defined in `distdir` namespace.

The design of the C++ bindings are similar to the Python bindings for consistency, since they are both
object oriented languages.

The library is initialized by calling the constructor of the `distdir` class:

\code
distdir::distdir::Ptr distdir( new distdir::distdir() );
\endcode

And it is finalized by calling the destructor:

\code
distdir.reset();
\endcode

A new group can be created using the `group` method of the `distdir` class.

\code
distdir->group(new_comm, work_comm, id);
\endcode

where the `work_comm` is the communicator containing all the processes running the application, the `id` is an integer 
which defines in which group each process belongs and `new_comm` is the new communicator.

The `distdir` class also contains methods to setup the library

\code
distdir->set_verbose(verbose_true)
distdir->set_exchanger(IsendIrecv1)
\endcode

The verbose type is specified using the `distdir_verbose` enumerator and
the exchanger type is specified using the `distdir_exchanger` enumerator.

A \c idxlist class is defined which allows to create an index list. A `idxlist` object can be created 
by passying a \c vector to the constructor:

\code
distdir::idxlist::Ptr idxlist( new distdir::idxlist(list) );
\endcode

where `list` is a `std::vector<int>`. The design of the C++ bindings is based on shared pointers, so each class defines a 
shared pointer type to itself `distdir::idxlist::Ptr`.

An empty \c idxlist object can be created by not passing any array to the constructor:

\code
distdir::idxlist::Ptr idxlist_empty( new distdir::idxlist() );
\endcode

The destructor of the `idxlist` class frees the memory internally generated:

\code
idxlist.reset();
\endcode

A \c map class is defined which allows to create a map.
A \c map object can be created by passing the source and destination \c idxlist objects shared pointers and
the MPI communicator

\code
distdir::map::Ptr map( new distdir::map(idxlist, idxlist_empty, MPI_COMM_WORLD) );
\endcode

In addition the \c stride argument can be passed

\code
distdir::map::Ptr map( new distdir::map(idxlist, idxlist_empty, stride, MPI_COMM_WORLD) );
\endcode

The default stride is -1 which means that striding is not used internally to generate the map.

In case the \c map object is generated expanding a 2D object, the constructor can be used as follows

\code
distdir::map::Ptr map( new distdir::map(map2d, nlevels) );
\endcode

where \c map2d is a shared pointer to a map object generated previously.

An \c exchanger object can be generated passing the \c map object shared pointer, the hardware type and 
the MPI datatype

\code
distdir::exchanger<int>::Ptr exchanger ( new distdir::exchanger<int>(map, MPI_INT, CPU) );
\endcode

The \c exchanger class is templated, in the example it is specified which is used for \c int types and 
the type has to match the MPI datatype passed to the constructor. The hardware type is specified using 
the \c distdir_hardware enumerator defined in the C library. If not specified, the default hardware type 
is the CPU:

\code
distdir::exchanger<int>::Ptr exchanger ( new distdir::exchanger<int>(map, MPI_INT) );
\endcode

The main difference with the Python bindings is that the `exchanger` class is templated in C++ and there is no 
default MPI datatype.

The data to be exchanger has to be defined in a \c vector. Finally, the `go` method of the `exchanger` class
can be called

\code
exchanger->go(data, data);
\endcode

If a transformation is provided on the data layout, the following method can be used:

\code
exchanger->go(data, data, transform_src, transform_dst);
\endcode

where `transform_src` and `transform_dst` are vector of type \c int.

If compared with the C API described in the \ref start page, the C++ interface has an object oriented design.

All the C examples provided in the `examples` folder are replicated in C++ in the `bindings/C++/examples` folder.





\section fortran Fortran

Fortran bindings are generated passing \c -DENABLE_FORTRAN=ON to the configuration command and the `distdir_mod` module 
is installed in the `modules` folder. Then, the module can be used in a Fortran program with

\code
USE distdir_mod
\endcode

The library is initialized and finalized as follows:

\code
CALL distdir_initialize()
...
CALL distdir_finalize()
\endcode

A new group can be created by calling the following subroutine:

\code
CALL new_group(new_comm, work_comm, id)
\endcode

where the `work_comm` is the communicator containing all the processes running the application, the `id` is an integer 
which defines in which group each process belongs and `new_comm` is the new communicator.

The following subroutines can be used to set up the library:

\code
CALL set_config_verbose(verbose_type)
CALL set_config_exchanger(exchanger_type)
\endcode

The verbose type is specified using one of the following parameters:

\code
DISTDIR_VERBOSE_TRUE
DISTDIR_VERBOSE_FALSE
\endcode

The exchanger type is specified using one of the following parameters:

\code
DISTDIR_EXCHANGER_IsendIrecv1
DISTDIR_EXCHANGER_IsendIrecv2
DISTDIR_EXCHANGER_IsendRecv1
DISTDIR_EXCHANGER_IsendRecv2
DISTDIR_EXCHANGER_IsendIrecv1NoWait
DISTDIR_EXCHANGER_IsendIrecv2NoWait
DISTDIR_EXCHANGER_IsendRecv1NoWait
DISTDIR_EXCHANGER_IsendRecv2NoWait
\endcode

A new index list can be created passing a 1D integer array with the list of global indices and its size:

\code
CALL new_idxlist(idxlist, list, npoints_local)
\endcode

where `idxlist` is a variable of type `TYPE(t_idxlist)`.

An empty index list can be generated without passing any list:

\code
CALL new_idxlist(idxlist_empty)
\endcode

A map can be generated by passing the source and destination index lists and the MPI communicator:

\code
CALL new_map(map, idxlist, idxlist_empty, MPI_COMM_WORLD)
\endcode

where `map` is a variable of type `TYPE(t_map)`. In addition the `stride` argument can be passed:

\code
CALL new_map(map, idxlist, idxlist_empty, stride, comm)
\endcode

The default stride is -1 which means that striding is not used internally.

In case the map is generated expanding a 2D map, the `new_map` subroutine can be called as follows:

\code
CALL new_map(map, map2d, nlevels)
\endcode

where the `map2d` is a variable of type `TYPE(t_map)`.

An exchanger can be generated passing the previously created map, the hardware type and the MPI datatype:

\code
CALL new_exchanger(exchanger, map, type, hw)
\endcode

The \c exchanger variable is of type `TYPE(t_exchanger)`. The `type` is an MPI datatype and the `hw` variable is
an integer which can have the following values:

\code
DISTDIR_HW_CPU
DISTDIR_HW_GPU_NVIDIA
DISTDIR_HW_GPU_AMD
\endcode

The default hardware is the CPU, so the exchanger can also be created as follows:

\code
CALL new_exchanger(exchanger, map, type)
\endcode

The data to be exchanger has to be defined in a 1D array. Finally, the \c exchanger_go subroutine can be called:

\code
CALL exchanger_go(exchanger, C_LOC(data(1)), C_LOC(data(1)))
\endcode

If a transformation is provided on the data layout, the following subroutine can be used:

\code
CALL exchanger_go(exchanger, C_LOC(data(1)), C_LOC(data(1)), transform_src, transform_dst)
\endcode

where `transform_src` and `transform_dst` are 1D integer arrays.

The design of the Fortran bindings is very comparable to the C interface with the addition of function overloading which 
makes it slimmer.

All the C examples provided in the `examples` folder are replicated in Fortran in the `bindings/Fortran/examples` folder.





\section julia Julia

The development of Julia bindings has followed a different strategy. Since Julia development is standardized,
a <a href="https://github.com/EnricoDeg/DistDir.jl">DistDir.jl</a> package was created which is a submodule in the main 
DistDir repository. Since Julia is just in time (JIT) compiled, the module needs to open the library (using \c dlopen),
so `LOAD_PATH` or `LD_LIBRARY_PATH` needs to be set to the location where the library is installed. In addition to that, 
the `JULIA_LOAD_PATH` needs to be set to the location of the `DistDir.jl` folder in order to be able to import the module
in your Julia application. This step is needed because `DistDir.jl` is not an official package.

The library is initialized and finalized calling the following functions

\code
DistDir.initialize()
...
DistDir.finalize()
\endcode

A \c idxlist object can be created passing a integer vector with the list of global indices

\code
idxlist::DistDir.t_idxlist_jl = DistDir.new_idxlist(list)
\endcode

where `idxlist` is a variable of type `t_idxlist_jl`.

An empty idxlist object can be generated without passing any list

\code
idxlist_empty::DistDir.t_idxlist_jl = DistDir.new_idxlist()
\endcode

A \c map object can be created by passing the source and destination \c idxlist objects and
the MPI communicator

\code
map :: DistDir.t_map_jl = DistDir.new_map(idxlist, idxlist_empty, MPI.COMM_WORLD)
\endcode

where `map` is a variable of type `t_map_jl`. In addition the \c stride argument can be passed

\code
map :: DistDir.t_map_jl = DistDir.new_map(idxlist, idxlist_empty, stride, MPI.COMM_WORLD)
\endcode

In case the \c t_map object is generated expanding a 2D object, the constructor can be used as follows

\code
map :: DistDir.t_map_jl = DistDir.new_map(map2d, nlevels)
\endcode

where the \c map2d is a \c t_map_jl variable.

A \c exchanger object can be generated passing the \c map object, the hardware type and 
the MPI datatype

\code
exchanger :: DistDir.t_exchanger_jl = DistDir.new_exchanger(map, MPI.Datatype(Float64), hw)
\endcode

The \c exchanger variable is of type \c t_exchanger_jl. The type is an MPI datatype, like MPI.Datatype(Float64) for 
doubles, and the hardware is an integer which can be defined using the following enumerator:

\code
@enum distdir_hardware begin
	CPU = 0
	GPU_NVIDIA = 1
	GPU_AMD = 2
end
\endcode

The default hardware is the CPU, so the exchanger can also be created as follows

\code
exchanger :: DistDir.t_exchanger_jl = DistDir.new_exchanger(map, MPI.Datatype(Float64))
\endcode

The data to be exchanger has to be defined in a vector. Finally, the \c exchanger_go function can be called

\code
DistDir.exchanger_go(exchanger, data, data)
\endcode

If a transformation is provided on the data layout

\code
DistDir.exchanger_go(exchanger, data, data, transform_src, transform_dst)
\endcode

where `transform_src` and `transform_dst` are integer vectors.

Finally, a Julia script can be launched as follows:

\code
mpiexecjl -n 4 julia example_basic1.jl
\endcode

The Julia interface is very comparable to the Fortran one. All the C examples provided in the `examples` folder 
are replicated in Fortran in the `bindings/Julia/examples` folder.

*/