/**
 * \page bindings Bindings

\tableofcontents

\section python Python

The generation of python bindings has the objective to simplify the usage of the library, allowing 
users without low level programming experience to exploit the library in their applications. Python is a natural 
choice because of its wide usage and its simplicity. Using DistDir library in a python script allows to fully hide the 
complexity of the language and the algorithm to the end users.

A python module \c pydistdir can be generated by adding \c -DENABLE_PYTHON=ON option to the configuration command 
described in the \ref installation page. Once the python module is installed, the folder needs to be added to the 
\c PYTHONPATH environment variable. The generation of the python module requires \c cython and \c mpi4py which can be 
easily installed using \c pip.

This section describe the usage of the library in a python script. The basic principles of the library are still 
the same, but the interface is slightly different.

First of all, the module must be loaded

\code
import pydistdir
\endcode

Then the library needs to be initialized by calling the constructor of the \c distdir class

\code
dd = pydistdir.distdir()
\endcode

The finalization step is handled by python after that all the destructors of the generated objects are called by 
the garbage collector, so the user does not need to worry to destroy objects or finalize the library.

A \c t_idxlist object can be created easily passying a \c numpy array or a tuple:

\code
src_idxlist = pydistdir.idxlist([0, 1, 4, 5, 8, 9, 12, 13])
\endcode

An empty \c t_idxlist object can be created not passing any array to the constructor

\code
dst_idxlist = pydistdir.idxlist()
\endcode

A \c t_map object can be created by passing the source and destination \c t_idxlist objects and the MPI communicator

\code
map = pydistdir.map(src_idxlist=src_idxlist, dst_idxlist=dst_idxlist, comm=MPI.COMM_WORLD)
\endcode

In addition the \c stride argument can be passed

\code
map = pydistdir.map(src_idxlist=src_idxlist, dst_idxlist=dst_idxlist, comm=MPI.COMM_WORLD, stride=8)
\endcode

In case the \c t_map object is generated expanding a 2D object, the constructor can be used as follows

\code
map = pydistdir.map(map2d=map2d, nlevels=10)
\endcode

where the \c map2d objects was generated by a previous call to \c pydistdir.map.

A \c t_exchanger object can be generated passing the \c t_map object, the hardware type and 
the MPI datatype

\code
exchanger = pydistdir.exchanger(map, hw, type)
\endcode

where the `hw` argument is an \c enum which can be initialized with the following values:

\code
hw = pydistdir.pydistdir_hardware.CPU
hw = pydistdir.pydistdir_hardware.GPU_NVIDIA
hw = pydistdir.pydistdir_hardware.GPU_AMD
\endcode

and type is an MPI datatype. The following are supported: `MPI.DOUBLE`, `MPI.FLOAT` and `MPI.INT`.

The default hardware is the CPU and the default type is `MPI.DOUBLE`,
so the exchanger can also be created as follows:

\code
exchanger = pydistdir.exchanger(map)
\endcode

The data to be exchanger can be allocated as a numpy array

\code
data = np.array([0, 1, 2, 3, 4, 5, 6, 7], dtype = np.double)
\endcode

Finally the \c go method of the \c t_exchanger class can be called

\code
exchanger.go(data, data)
\endcode

If a transformation is provided on the data layout

\code
exchanger.go(data, data, transform_src, transform_dst)
\endcode

where `transform_src` and `transform_dst` are integer \c numpy arrays.

If compared with the C API described in the \ref start page, the python interface is significantly easier even if with 
minor limitations which will be tackled in future developments.

All the C examples provided in the `examples` folder are replicated in python in the `bindings/python/examples` folder.

*/