/**
 * \page bindings Bindings

\tableofcontents

\section python Python

The generation of python bindings has the objective to simplify the usage of the library, allowing 
users without low level programming experience to exploit the library in their applications. Python is a natural 
choice because of its wide usage and its simplicity. Using DistDir library in a python script allows to fully hide the 
complexity of the language and the algorithm to the end users.

A python module \c pydistdir can be generated by adding \c -DENABLE_PYTHON=ON option to the configuration command 
described in the \ref installation page. Once the python module is installed, the folder needs to be added to the 
\c PYTHONPATH environment variable. The generation of the python module requires \c cython and \c mpi4py which can be 
easily installed using \c pip.

This section describe the usage of the library in a python script. The basic principles of the library are still 
the same, but the interface is slightly different.

First of all, the module must be loaded

\code
import pydistdir
\endcode

Then the library needs to be initialized by calling the constructor of the \c distdir class

\code
dd = pydistdir.distdir()
\endcode

The finalization step is handled by python after that all the destructors of the generated objects are called by 
the garbage collector, so the user does not need to worry to destroy objects or finalize the library.

A \c t_idxlist object can be created easily passying a \c numpy array or a tuple:

\code
src_idxlist = pydistdir.idxlist([0, 1, 4, 5, 8, 9, 12, 13])
\endcode

An empty \c t_idxlist object can be created not passing any array to the constructor

\code
dst_idxlist = pydistdir.idxlist()
\endcode

A \c t_map object can be created by passing the source and destination \c t_idxlist objects and the MPI communicator

\code
map = pydistdir.map(src_idxlist=src_idxlist, dst_idxlist=dst_idxlist, comm=MPI.COMM_WORLD)
\endcode

In addition the \c stride argument can be passed

\code
map = pydistdir.map(src_idxlist=src_idxlist, dst_idxlist=dst_idxlist, comm=MPI.COMM_WORLD, stride=8)
\endcode

In case the \c t_map object is generated expanding a 2D object, the constructor can be used as follows

\code
map = pydistdir.map(map2d=map2d, nlevels=10)
\endcode

where the \c map2d objects was generated by a previous call to \c pydistdir.map.

A \c t_exchanger object can be generated passing the \c t_map object, the hardware type and 
the MPI datatype

\code
exchanger = pydistdir.exchanger(map, hw, type)
\endcode

where the `hw` argument is an \c enum which can be initialized with the following values:

\code
hw = pydistdir.pydistdir_hardware.CPU
hw = pydistdir.pydistdir_hardware.GPU_NVIDIA
hw = pydistdir.pydistdir_hardware.GPU_AMD
\endcode

and type is an MPI datatype. The following are supported: `MPI.DOUBLE`, `MPI.FLOAT` and `MPI.INT`.

The default hardware is the CPU and the default type is `MPI.DOUBLE`,
so the exchanger can also be created as follows:

\code
exchanger = pydistdir.exchanger(map)
\endcode

The data to be exchanger can be allocated as a numpy array

\code
data = np.array([0, 1, 2, 3, 4, 5, 6, 7], dtype = np.double)
\endcode

Finally the \c go method of the \c t_exchanger class can be called

\code
exchanger.go(data, data)
\endcode

If a transformation is provided on the data layout

\code
exchanger.go(data, data, transform_src, transform_dst)
\endcode

where `transform_src` and `transform_dst` are integer \c numpy arrays.

If compared with the C API described in the \ref start page, the python interface is significantly easier even if with 
minor limitations which will be tackled in future developments.

All the C examples provided in the `examples` folder are replicated in python in the `bindings/python/examples` folder.

\section cpp C++

A tiny wrapper around the library is generated to provide C++ bindings. This is not strictly necessary because a C library
can be called directly from C++, but since C++ is based on object oriented programming, a class-based interface
is provided for the C library. The header file `distdir.hpp` should be included. This is installed in the `include`
folder by adding \c -DENABLE_CXX=ON. The classed belonging to the C++ interface are all defined in \c distdir namespace.

The library is initialized by calling the constructor of the `distdir` class:

\code
distdir::distdir::Ptr distdir( new distdir::distdir() );
\endcode

And it is finalized by calling the destructor:

\code
distdir.reset();
\endcode

A \c idxlist object can be created passying a \c vector to the constructor:

\code
distdir::idxlist::Ptr idxlist( new distdir::idxlist(list) );
\endcode

where `list` is a `std::vector<int>`.

An empty \c idxlist object can be created not passing any array to the constructor

\code
distdir::idxlist::Ptr idxlist_empty( new distdir::idxlist() );
\endcode

A \c map object can be created by passing the source and destination \c idxlist objects shared pointers and
the MPI communicator

\code
distdir::map::Ptr map( new distdir::map(idxlist, idxlist_empty, MPI_COMM_WORLD) );
\endcode

In addition the \c stride argument can be passed

\code
distdir::map::Ptr map( new distdir::map(idxlist, idxlist_empty, stride, MPI_COMM_WORLD) );
\endcode

In case the \c t_map object is generated expanding a 2D object, the constructor can be used as follows

\code
distdir::map::Ptr map( new distdir::map(map2d, nlevels) );
\endcode

where the \c map2d is a shared pointer to a map object.

A \c exchanger object can be generated passing the \c map object shared pointer, the hardware type and 
the MPI datatype

\code
distdir::exchanger<int>::Ptr exchanger ( new distdir::exchanger<int>(map, MPI_INT, CPU) );
\endcode

The \c exchanger class is templated, in the example it is specified which is used for \c int types and 
the type has to match the MPI datatype passed to the constructor. The hardware type is specified using 
the \c distdir_hardware enumerator defined in the C library. If not specified, the default hardware type 
is the CPU:

\code
distdir::exchanger<int>::Ptr exchanger ( new distdir::exchanger<int>(map, MPI_INT) );
\endcode

The data to be exchanger has to be defined in a \c vector. Finally, the \c go method of the \c exchanger class
can be called

\code
exchanger->go(data, data);
\endcode

If a transformation is provided on the data layout

\code
exchanger->go(data, data, transform_src, transform_dst);
\endcode

where `transform_src` and `transform_dst` are vector of type \c int.

If compared with the C API described in the \ref start page, the C++ interface has an object oriented design.

All the C examples provided in the `examples` folder are replicated in C++ in the `bindings/C++/examples` folder.

\section fortran Fortran

Fortran bindings are generated passing \c -DENABLE_FORTRAN=ON to the configuration command and the `distdir_mod` module 
is installed in the `modules` folder. Then, the module can be used in a Fortran program with

\code
USE distdir_mod
\endcode

The library is initialized and finalized as follows:

\code
CALL distdir_initialize()
...
CALL distdir_finalize()
\endcode

A \c idxlist object can be created passing a 1D integer array with the list of global indices and its size

\code
CALL new_idxlist(idxlist, list, npoints_local)
\endcode

where `idxlist` is a variable of type `t_idxlist`.

An empty idxlist object can be generated without passing any list

\code
CALL new_idxlist(idxlist_empty)
\endcode

A \c map object can be created by passing the source and destination \c idxlist objects and
the MPI communicator

\code
CALL new_map(map, idxlist, idxlist_empty, MPI_COMM_WORLD)
\endcode

where `map` is a variable of type `t_map`. In addition the \c stride argument can be passed

\code
CALL new_map(map, idxlist, idxlist_empty, stride, comm)
\endcode

In case the \c t_map object is generated expanding a 2D object, the constructor can be used as follows

\code
CALL new_map(map, map2d, nlevels)
\endcode

where the \c map2d is a \c t_map object.

A \c exchanger object can be generated passing the \c map object, the hardware type and 
the MPI datatype

\code
CALL new_exchanger(exchanger, map, type, hw)
\endcode

The \c exchanger variable is of type \c t_exchanger. The type is an MPI datatype and the hardware is an integer
which can have the following values:

\code
DISTDIR_HW_CPU
DISTDIR_HW_GPU_NVIDIA
DISTDIR_HW_GPU_AMD
\endcode

The default hardware is the CPU, so the exchanger can also be created as follows

\code
CALL new_exchanger(exchanger, map, type)
\endcode

The data to be exchanger has to be defined in a 1D array. Finally, the \c exchanger_go function can be called

\code
CALL exchanger_go(exchanger, C_LOC(data(1)), C_LOC(data(1)))
\endcode

If a transformation is provided on the data layout

\code
CALL exchanger_go(exchanger, C_LOC(data(1)), C_LOC(data(1)), transform_src, transform_dst)
\endcode

where `transform_src` and `transform_dst` are 1D integer arrays.

The Fortran bindings are very comparable to the C interface with the addition of function overloading which 
makes it slimmer.

All the C examples provided in the `examples` folder are replicated in Fortran in the `bindings/Fortran/examples` folder.

\section julia Julia

The development of Julia bindings has followed a different strategy. Since Julia development is standardized,
a <a href="https://github.com/EnricoDeg/DistDir.jl">DistDir.jl</a> package was created which is a submodule in the main 
DistDir repository. Since Julia is just in time compiled, the module needs to open the library (using \c dlopen),
so `LOAD_PATH` or `LD_LIBRARY_PATH` needs to be set to the location where the library is installed. In addition to that, 
the `JULIA_LOAD_PATH` needs to be set to the location of the `DistDir.jl` folder in order to be able to import the module
in your Julia application. This step is needed because `DistDir.jl` is not an official package.

The library is initialized and finalized calling the following functions

\code
DistDir.initialize()
...
DistDir.finalize()
\endcode

A \c idxlist object can be created passing a integer vector with the list of global indices

\code
idxlist::DistDir.t_idxlist_jl = DistDir.new_idxlist(list)
\endcode

where `idxlist` is a variable of type `t_idxlist_jl`.

An empty idxlist object can be generated without passing any list

\code
idxlist_empty::DistDir.t_idxlist_jl = DistDir.new_idxlist()
\endcode

A \c map object can be created by passing the source and destination \c idxlist objects and
the MPI communicator

\code
map :: DistDir.t_map_jl = DistDir.new_map(idxlist, idxlist_empty, MPI.COMM_WORLD)
\endcode

where `map` is a variable of type `t_map_jl`. In addition the \c stride argument can be passed

\code
map :: DistDir.t_map_jl = DistDir.new_map(idxlist, idxlist_empty, stride, MPI.COMM_WORLD)
\endcode

In case the \c t_map object is generated expanding a 2D object, the constructor can be used as follows

\code
map :: DistDir.t_map_jl = DistDir.new_map(map2d, nlevels)
\endcode

where the \c map2d is a \c t_map_jl variable.

A \c exchanger object can be generated passing the \c map object, the hardware type and 
the MPI datatype

\code
exchanger :: DistDir.t_exchanger_jl = DistDir.new_exchanger(map, MPI.Datatype(Float64), hw)
\endcode

The \c exchanger variable is of type \c t_exchanger_jl. The type is an MPI datatype, like MPI.Datatype(Float64) for 
doubles, and the hardware is an integer which can be defined using the following enumerator:

\code
@enum distdir_hardware begin
	CPU = 0
	GPU_NVIDIA = 1
	GPU_AMD = 2
end
\endcode

The default hardware is the CPU, so the exchanger can also be created as follows

\code
exchanger :: DistDir.t_exchanger_jl = DistDir.new_exchanger(map, MPI.Datatype(Float64))
\endcode

The data to be exchanger has to be defined in a vector. Finally, the \c exchanger_go function can be called

\code
DistDir.exchanger_go(exchanger, data, data)
\endcode

If a transformation is provided on the data layout

\code
DistDir.exchanger_go(exchanger, data, data, transform_src, transform_dst)
\endcode

where `transform_src` and `transform_dst` are integer vectors.

Finally, a Julia script can be launched as follows:

\code
mpiexecjl -n 4 julia example_basic1.jl
\endcode

The Julia interface is very comparable to the Fortran one. All the C examples provided in the `examples` folder 
are replicated in Fortran in the `bindings/Julia/examples` folder.

*/