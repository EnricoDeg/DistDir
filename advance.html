<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DistDir: Advance Topics</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DistDir
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Advance Topics </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#config">Configuration parameters</a></li>
<li class="level1"><a href="#map3d">Mapping 3D fields</a></li>
<li class="level1"><a href="#exchanger">Exchanger methods</a></li>
<li class="level1"><a href="#transform">Memory layout transformation</a></li>
<li class="level1"><a href="#gpu_backend">GPU backend</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="config"></a>
Configuration parameters</h1>
<p>When the library is initialized calling <code>distdir_initialize</code>, a <code><a class="el" href="structt__config.html">t_config</a></code> structure is internally created. It contains the settings of the library which can be specified as environment variables or using API functions. At the moment, the following settings are supported:</p>
<ul>
<li>exchanger type: it can be specified using the environment variable <code>DISTDIR_EXCHANGER</code> or the API function <code>set_config_exchanger</code> </li>
<li>verbose mode: it can be specified using the environment variable <code>DISTDIR_VERBOSE</code> or the API function <code>set_config_verbose</code> </li>
</ul>
<p>The exchanger type specifies the type of exchange. An enumerator is defined internally:</p>
<ul>
<li><code>IsendIrecv1=0</code> : each buffer to be sent is filled and then sent with a call to <code>MPI_Isend</code>, while all the buffers to be received are received with a call to <code>MPI_Irecv</code>, then <code>MPI_Waitall</code> is called and the received buffers are unpacked into the field data array</li>
<li><code>IsendIrecv2=1</code> : all buffers to be sent are first filled and then sent with calls to <code>MPI_Isend</code>, while all the buffers to be received are received with calls to <code>MPI_Irecv</code>, then <code>MPI_Waitall</code> is called and the received buffers are unpacked into the field data array</li>
<li><code>IsendRecv1=2</code> : each buffer to be sent is filled and then sent with a call to <code>MPI_Isend</code>, then <code>MPI_Waitall</code> l is called. Finally, all the buffers to be received are received with a call to <code>MPI_Recv</code> and as the final step all the received buffers are unpacked into the field data array</li>
<li><code>IsendRecv2=3</code> : each buffer to be sent is filled and then sent with a call to <code>MPI_Isend</code>, then <code>MPI_Waitall</code> is called. Finally, all the buffers to be received are received with a call to <code>MPI_Recv</code> and immediately unpacked into the field data array.</li>
<li><code>IsendIrecv1NoWait=4</code> : same as <code>IsendIrecv1</code> but the sending messages are waited during the next call to the function or during the call to <code>delete_exchanger</code>. It can be used only when the sending processes and the receiving processes do not overlap, i.e. concurrent implementations.</li>
<li><code>IsendIrecv2NoWait=5</code> : same as <code>IsendIrecv2</code> but the sending messages are waited during the next call to the function or during the call to <code>delete_exchanger</code>. It can be used only when the sending processes and the receiving processes do not overlap, i.e. concurrent implementations.</li>
<li><code>IsendRecv1NoWait=6</code> : same as <code>IsendRecv1</code> but the sending messages are waited during the next call to the function or during the call to <code>delete_exchanger</code>. It can be used only when the sending processes and the receiving processes do not overlap, i.e. concurrent implementations.</li>
<li><code>IsendRecv2NoWait=7</code> : same as <code>IsendRecv2</code> but the sending messages are waited during the next call to the function or during the call to <code>delete_exchanger</code>. It can be used only when the sending processes and the receiving processes do not overlap, i.e. concurrent implementations.</li>
</ul>
<p>The default exchanger is <code>IsendIrecv1</code>. The environment variable would set this parameter globally, while the API allows to set it per <code><a class="el" href="structt__exchanger.html">t_exchanger</a></code> object. This means that given the same map, fields exchanged with different exchangers but having the same communication path, can use different type of exchange. In this case the API function must be called before the call to <code>new_exchanger</code>, which creates a <code><a class="el" href="structt__exchanger.html">t_exchanger</a></code> object.</p>
<p>The verbose mode specifies if the library should run in verbose mode or not. An enumerator is defined internally:</p>
<ul>
<li><code>verbose_true=0</code> </li>
<li><code>verbose_false=1</code> </li>
</ul>
<p>This parameter is self explanatory.</p>
<h1><a class="anchor" id="map3d"></a>
Mapping 3D fields</h1>
<p>The mapping of 3D fields is computationally more expensive and the choice of the RD decomposition is crucial to achieve good performance in computing the exchange pattern (<a class="el" href="structt__map.html">t_map</a> object). The idea of the library to tackle this problem is to optimize the mapping algorithm for 2D fields and then adapt it to the third dimension. This is straightforward if an application used only 2D domain decomposition, such as many climate and NWP applications.</p>
<p>In this case, the optimal way to use the library is to create a <a class="el" href="structt__map.html">t_map</a> object for the exchange of 3D fields in two stages:</p>
<ul>
<li>create a <a class="el" href="structt__map.html">t_map</a> object calling the <code>new_map</code> API function and providing the global indices of the 2D decomposition for the first vertical level</li>
<li>use the <a class="el" href="structt__map.html">t_map</a> object to create another <a class="el" href="structt__map.html">t_map</a> object which extrapolate the exchange pattern in the third dimension, where there is no domain decomposition. This is achieved using the <code>extend_map_3d</code> API function which requires the <a class="el" href="structt__map.html">t_map</a> object based on the 2D decomposition on a single vertical level and the number of level on which the user wants to extrapolate the <a class="el" href="structt__map.html">t_map</a> object. A new <a class="el" href="structt__map.html">t_map</a> object is created and can be used to create the <a class="el" href="structt__exchanger.html">t_exchanger</a> objects, thus the initally create <a class="el" href="structt__map.html">t_map</a> object can be immediately deleted.</li>
</ul>
<p>The creation of maps with extrapolation is very convenient and it should provide optimal performance. However, it is not applicable to a large range of applications. In particular, this method is not applicable to applications having 3D domain decomposition, such as any CFD application.</p>
<p>In this case, the <code>new_map</code> function must be used directly to create the <a class="el" href="structt__map.html">t_map</a> object for 3D fields. However, the user can provide an additional argument to the function which allows to create bucket strides based on the 2D global domain. The stride parameter should have the value of the number of points in the global 2D domain. Internally, the library is creating buckets based on the stride parameter which are identical to the ones which would be generated with a 2D slice of the same field. Then, the buckets are strided and there will be one stride of each bucket on each vertical level of the 3D field. Then, the forward mapping to the RD decomposition and the backward mapping to the original decomposition is done as usual. The 3D mapping done in this way is still significantly more computationally expensive than the 2D mapping but it is expected to still provide good performance which covers a wide range of applications.</p>
<h1><a class="anchor" id="exchanger"></a>
Exchanger methods</h1>
<p>In the <a class="el" href="advance.html#config">Configuration parameters</a> section, the different exchanger types supported by the library have been already introduced and explained.</p>
<p>The purpose of this section is to provide some guidance on the usage of the exchanger types based on different applications. As it was explained in the <a class="el" href="rationale.html">Rationale</a> page, the main goal of the library is to remove the complexity of the exchange when concurrent execution is implemented in a scientific application. The supported exchanger types mirrors this basic idea which originally drove the library development.</p>
<p>Concurrent execution is crucial for many scientific application to target exascale systems because it allows to optimally scale each component and to run each component on the optimal hardware. Concurrent execution always involves exchange points between components. This exchange can be in one direction or in both directions.</p>
<p>In case of two way exchange, both components send and receive information during an exchange point. This means that only <code>IsendIrecv1</code>, <code>IsendIrecv2</code>, <code>IsendRecv1</code> or <code>IsendRecv2</code> can be used. The optimal exchanger is highly dependent on the application itself and the MPI implementation. The developers recommend to test the different exchanger types for each specific usage.</p>
<p>In case of one way exchange, <code>IsendIrecv1</code>, <code>IsendIrecv2</code>, <code>IsendRecv1</code> or <code>IsendRecv2</code> can be used but they would be suboptimal because the sending processes do not need to wait for the messages to be received. For this reason, <code>IsendIrecv1NoWait</code>, <code>IsendIrecv2NoWait</code>, <code>IsendRecv1NoWait</code> or <code>IsendRecv2NoWait</code> are recommended. In this case, the sending processes fill the buffers and start a non blocking send. Afterwards they continue with the next step and they will wait for the sending messages only right before the next exchange. In this way, overlapping of communication and computation can be fully achieved on the sending processes. This is crucial if we think about a real case application. A classic example is a climate model which uses IO servers to perform output files writing during the time loop. In this case, the communication between the client processes and the server processes is one way. Using the <code>nowait</code> exchangers, the client processes fill the buffer and call <code>MPI_Isend</code> without waiting for the messages to be received and continue with the heavy computations. During the following writing step, they wait for the messages of the previous writing step and then fill the buffer and send the new data.</p>
<p>The <code>nowait</code> exchangers can only be used when the sending and receiving processes belong to two non overlapping groups. This means that they can not be used then the data are sent to a subset of processes which is another well known strategy to optimize the output files writing or when a transposition is done for spectral method. The range of applications using the <code>nowait</code> exchangers is limited but those cases are widely used and they are expected to be fully optimized with those exchangers. As mentioned for the other exchangers, the choice between the <code>nowait</code> exchangers depends on the application and the MPI implementation, this the users should test the different <code>nowait</code> exchanger types for their specific use cases.</p>
<h1><a class="anchor" id="transform"></a>
Memory layout transformation</h1>
<p>Climate applications usually apply a runtime transformation to the memory layout for caching purposes. This means that if a 3D subdomain has a memory layout <code>[npoints_local, nlevels]</code> at runtime it can be transformed <code>[nproma, nlevels, nblocks]</code> where <code>nproma</code> is a runtime parameter. The library supports also this memory layout transformation. In this case, the index list has to be generated providing the global indices in the original layout. This means that the generated map is also based on the original layout.</p>
<p>When the data needs to be exchanged the API function <code>exchanger_go_with_transform</code> can be used to transform the original memory layout in the one defined at runtime. In this case, the transformation for the source and destination needs to be provided in the form of indices in a integer array.</p>
<p>An example:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> block = 0; block&lt;nblocks; block++)</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> level = 0; level&lt;nlevels; level++)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;nproma; k++)</div>
<div class="line">            transform[k+level*nproma+block*nlevels*nproma] = k+level*npoints_local+block*nproma;</div>
</div><!-- fragment --><p>During the packing of the buffer, the transformation is applied before filling the buffer and during the unpacking of the buffer, the transformation is applied before filling the data field.</p>
<h1><a class="anchor" id="gpu_backend"></a>
GPU backend</h1>
<p>The <code>new_exchanger</code> function requires a hardware type argument.</p>
<p>The hardware type specifies if the MPI ranks are running on CPU or GPU. An enumerator is defined internally:</p>
<ul>
<li><code>CPU=0</code> </li>
<li><code>GPU_NVIDIA=1</code> </li>
<li><code>GPU_AMD=2</code> </li>
</ul>
<p>The function API allows to set the hardware per MPI rank and per exchanger object. This means that a group of MPI processes can run on the GPU and send data to a group of MPI processes running on the CPU, but it also means that a group of MPI processes can send data from the GPU with one exchanger and send other data from the CPU with another exchanger using the same previously generated map.</p>
<p>If the exchanger runs on GPU, the pointer to the data passed to the <code>exchanger_go</code> or the <code>exchanger_go_with_transform</code> functions must be a GPU pointer. In case of memory layout transformation, the transform arrays need to be on GPU as well. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
